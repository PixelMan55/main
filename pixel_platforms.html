<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pixel Platforms</title>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%}
    body{display:flex;align-items:center;justify-content:center;background:linear-gradient(#6fb3ff,#cfe9ff);font-family:sans-serif;overflow:hidden;}
    .game-wrap{width:450px;max-width:90vw;height:900px;max-height:95vh;background:linear-gradient(#bfe9ff,#fff);border-radius:12px;box-shadow:0 12px 30px rgba(0,0,0,0.2);position:relative;overflow:hidden;display:flex;flex-direction:column;}
    header{display:flex;justify-content:space-between;align-items:center;padding:8px;z-index:5;}
    header h1{font-size:18px}
    canvas{flex:1;border-radius:8px;background:linear-gradient(180deg,#b3ecff,#e6fcff);display:block;width:100%;height:100%;animation:bgScroll 8s linear infinite;z-index:1}
    @keyframes bgScroll{0%{background-position:0 0;}100%{background-position:0 100%;}}
    .btn{background:#fff;border:none;border-radius:8px;padding:8px 12px;box-shadow:0 2px 6px rgba(0,0,0,0.2);font-weight:600;cursor:pointer;transition:transform 0.2s}
    .btn:hover{transform:scale(1.05)}
    #pauseMenu,#startMenu,#tutorialMenu{position:absolute;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);display:none;align-items:center;justify-content:center;flex-direction:column;color:#fff;z-index:10;animation:fadeIn 0.6s ease}
    #pauseMenu button,#startMenu button,#tutorialMenu button{margin:8px;padding:10px 20px;border:none;border-radius:8px;background:#fff;color:#000;font-weight:700;cursor:pointer;transition:transform 0.2s}
    #pauseMenu button:hover,#startMenu button:hover,#tutorialMenu button:hover{transform:scale(1.1)}
    #customizeMenu{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(255,255,255,0.95);border-radius:12px;padding:20px;display:none;flex-direction:column;align-items:center;z-index:20;box-shadow:0 8px 20px rgba(0,0,0,0.3)}
    #customizeMenu input{margin:10px}
    #colorPreview{width:60px;height:60px;border-radius:8px;border:2px solid #000;margin-top:10px;display:flex;align-items:center;justify-content:center;font-size:20px}
    #expressionSelect{margin-top:10px}
    @keyframes fadeIn { from {opacity:0; transform:translateY(-20px);} to {opacity:1; transform:translateY(0);} }
  </style>
</head>
<body>
  <div class="game-wrap">
    <header>
      <h1>Pixel Platforms</h1>
      <div>
        <span>Level: <span id="level">1</span></span> | 
        <span>Score: <span id="score">0</span></span>
        <button class="btn" id="pauseBtn">⏸ Pause</button>
      </div>
    </header>
    <canvas id="game"></canvas>

    <div id="pauseMenu">
      <h2>Game Paused</h2>
      <button id="continueBtn">Continue</button>
      <button id="restartBtn">Restart Level</button>
      <button id="mainMenuBtn">Main Menu</button>
      <button id="customizeBtn">Customize Character</button>
      <button id="saveBtn">Save Game</button>
      <button id="loadBtn">Load Game</button>
    </div>

    <div id="startMenu">
      <h1 style="animation:fadeIn 1.5s ease infinite alternate;">Pixel Platforms</h1>
      <button id="playBtn">Play</button>
      <button id="loadGameBtn">Load Game</button>
      <button id="tutorialBtn">Tutorial</button>
      <button id="customizeStartBtn">Customize Character</button>
    </div>

    <div id="tutorialMenu">
      <h2>Tutorial</h2>
      <p style="max-width:300px;text-align:center;">Use <b>A/D</b> or <b>Arrow Keys</b> to move, and <b>W</b> or <b>Space</b> to jump.<br><br>
      Avoid obstacles, reach the portal to go to the next level, and don’t fall off the screen!</p>
      <button id="tutorialBackBtn">Back</button>
    </div>

    <div id="customizeMenu">
      <h2>Customize Character</h2>
      <label>Color: <input type="color" id="colorPicker" value="#ffb703" /></label>
      <label>Outline: <input type="color" id="outlinePicker" value="#000000" /></label>
      <label>Expression:
        <select id="expressionSelect">
          <option value=":)">:)</option>
          <option value=":(">:(</option>
          <option value=":D">:D</option>
          <option value="o_o">o_o</option>
        </select>
      </label>
      <div id="colorPreview">:)</div>
      <button id="closeCustomize">Done</button>
    </div>
  </div>

<script>
// ----- CORE SETUP -----
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = 450, H = 900; canvas.width = W; canvas.height = H;
const gravity = 1400;
const keys = {};
addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if (e.key === 'Escape') togglePause(); });
addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

// UI elements
const pauseMenu = document.getElementById('pauseMenu');
const pauseBtn = document.getElementById('pauseBtn');
const customizeMenu = document.getElementById('customizeMenu');
const colorPicker = document.getElementById('colorPicker');
const outlinePicker = document.getElementById('outlinePicker');
const expressionSelect = document.getElementById('expressionSelect');
const colorPreview = document.getElementById('colorPreview');
const closeCustomize = document.getElementById('closeCustomize');

let paused = false;
function togglePause() { paused = !paused; pauseMenu.style.display = paused ? 'flex' : 'none'; }

// Pause menu buttons
document.getElementById('continueBtn').onclick = () => togglePause();
document.getElementById('restartBtn').onclick = () => loadLevel(levelIndex);
document.getElementById('mainMenuBtn').onclick = () => { pauseMenu.style.display = 'none'; paused = false; document.getElementById('startMenu').style.display = 'flex'; };
document.getElementById('customizeBtn').onclick = () => { customizeMenu.style.display = 'flex'; updatePreview(); };

// Save/load
function saveGame(){
  const saveData = { levelIndex, score, playerColor, outlineColor, playerExpression };
  localStorage.setItem('pixelPlatformSave', JSON.stringify(saveData));
  alert('Game Saved!');
}
function loadGame(){
  const data = localStorage.getItem('pixelPlatformSave');
  if (data){
    const saveData = JSON.parse(data);
    levelIndex = saveData.levelIndex || 0;
    score = saveData.score || 0;
    playerColor = saveData.playerColor || '#ffb703';
    outlineColor = saveData.outlineColor || '#000000';
    playerExpression = saveData.playerExpression || ':)';
    colorPicker.value = playerColor; outlinePicker.value = outlineColor; expressionSelect.value = playerExpression; updatePreview();
    loadLevel(levelIndex);
    alert('Game Loaded!');
  } else alert('No saved game found.');
}

document.getElementById('saveBtn').onclick = saveGame;
document.getElementById('loadBtn').onclick = loadGame;

// Customization preview
function updatePreview(){ colorPreview.style.background = colorPicker.value; colorPreview.style.borderColor = outlinePicker.value; colorPreview.textContent = expressionSelect.value; }
colorPicker.addEventListener('input', updatePreview); outlinePicker.addEventListener('input', updatePreview); expressionSelect.addEventListener('input', updatePreview);
closeCustomize.onclick = () => { playerColor = colorPicker.value; outlineColor = outlinePicker.value; playerExpression = expressionSelect.value; customizeMenu.style.display = 'none'; };

// ----- GAME STATE -----
let playerColor = '#ffb703';
let outlineColor = '#000000';
let playerExpression = ':)';
const player = { x:230, y:0, w:30, h:40, vx:0, vy:0, onGround:false, speed:220, jumpPower:-850 };
let score = 0, levelIndex = 0, cameraY = 0;

// ----- LEVEL GENERATION -----
function generateLevels(){
  let levels = [];
  for (let i=0;i<15;i++){
    let platforms = [];
    // starting blue platform lower
    platforms.push({ x:160, y:780, width:140, height:20, color:'#2196f3', type:'solid' });
    let difficulty = i+1;
    let lastX = -999;
    for (let j=1;j<10+Math.floor(difficulty/2);j++){
      let x,y,type;
      do { x = Math.random()*350; y = 780 - j*(120-difficulty*2) - i*30; } while (Math.abs(x-lastX) < 60);
      lastX = x;
      const rand = Math.random();
      if (rand < 0.2) type='moving'; else if (rand < 0.3) type='breaking'; else if (rand < 0.4) type='disappearing'; else type='solid';
      let color = '#2b6f47'; if (type==='moving') color='#4caf50'; else if (type==='breaking') color='#8b4513'; else if (type==='disappearing') color='#ff9800';
      platforms.push({ x, y, width:120, height:20, color, type, timer:0, dir:1 });
    }
    let obstacles = [];
    for (const p of platforms.slice(1)){
      if (Math.random() < 0.4){
        const moveDir = Math.random() < 0.5 ? -1 : 1;
        obstacles.push({ x: p.x + p.width/2 - 15, y: p.y - 30, size:30, color:'#d62828', dir: moveDir, speed:60, moving: Math.random() < 0.5 });
      }
    }
    const portalY = Math.min(...platforms.map(p=>p.y)) - 100;
    levels.push({ platforms, portal: { x: Math.random()*350+50, y: portalY, width:60, height:30, angle: 0 }, obstacles });
  }
  return levels;
}
let levels = generateLevels();

// ----- CORE GAME FUNCTIONS -----
function rectsOverlap(a,b){ return a.x < b.x + b.width && a.x + a.w > b.x && a.y < b.y + b.height && a.y + a.h > b.y; }

function resolveMovement(e, platforms, dt){
  e.x += e.vx * dt; e.y += e.vy * dt; e.onGround = false;
  for (const p of platforms){
    if (rectsOverlap({x:e.x,y:e.y,w:e.w,h:e.h}, p)){
      if (e.vy > 0){ e.y = p.y - e.h; e.vy = 0; e.onGround = true; if (p.type === 'breaking') { p.remove = true; } }
      else if (e.vy < 0){ e.y = p.y + p.height; e.vy = 0; }
    }
  }
  for (let i = platforms.length-1; i >= 0; i--){ if (platforms[i].remove) platforms.splice(i,1); }
}

function nextLevel(){ if (levelIndex < levels.length - 1){ levelIndex++; loadLevel(levelIndex); score += 100; } else { alert('You completed all 15 levels! Score:'+score); localStorage.clear(); location.reload(); } }

// Important: define loadLevel BEFORE any code uses it (fixes the ReferenceError)
function loadLevel(i){
  levelIndex = i;
  // ensure levels exist
  if (!levels || levels.length === 0) levels = generateLevels();
  const startPlat = levels[i].platforms[0];
  player.x = startPlat.x + startPlat.width/2 - player.w/2;
  player.y = startPlat.y - player.h;
  player.vx = 0; player.vy = 0; player.onGround = true; cameraY = 0;
  paused = false; pauseMenu.style.display = 'none';
  document.getElementById('level').textContent = i+1;
}

// Save/load already defined above

// ----- GAME LOOP -----
let last = performance.now();
function update(now){
  const dt = Math.min((now - last)/1000, 1/15); last = now;
  if (paused) return requestAnimationFrame(update);
  const level = levels[levelIndex];
  let move = 0; if (keys['arrowleft']||keys['a']) move -= 1; if (keys['arrowright']||keys['d']) move += 1;
  if ((keys[' ']||keys['w']||keys['arrowup']) && player.onGround) { player.vy = player.jumpPower; player.onGround = false; }
  player.vx = move * player.speed; player.vy += gravity * dt;

  for (const p of level.platforms){
    if (p.type === 'moving'){ p.x += p.dir * dt * 60; if (p.x < 0 || p.x + p.width > W) p.dir *= -1; }
    else if (p.type === 'disappearing'){
      p.timer += dt;
      if (!p.hidden && p.timer > 5){ p.hidden = true; p.timer = 0; }
      else if (p.hidden && p.timer > 2){ p.hidden = false; p.timer = 0; }
    }
  }

  for (const o of level.obstacles){ if (o.moving){ o.x += o.dir * o.speed * dt; if (o.x < 0 || o.x + o.size > W) o.dir *= -1; } }

  resolveMovement(player, level.platforms.filter(p=>!p.hidden), dt);

  // camera follows player upwards; cameraY is negative or zero
  cameraY = Math.min(cameraY, player.y - H/2);

  // fall off visible camera = restart
  if (player.y > cameraY + H){ alert('You fell off! Restarting level...'); loadLevel(levelIndex); return requestAnimationFrame(update); }

  // obstacle collisions
  for (const o of level.obstacles){
    const hit = player.x < o.x + o.size && player.x + player.w > o.x && player.y < o.y + o.size && player.y + player.h > o.y;
    if (hit){ alert('You hit an obstacle! Restarting level...'); loadLevel(levelIndex); return requestAnimationFrame(update); }
  }

  if (rectsOverlap({x:player.x,y:player.y,w:player.w,h:player.h}, level.portal)) nextLevel();

  // animate portal
  level.portal.angle += dt * 180;

  render(level);
  requestAnimationFrame(update);
}

// ----- RENDER -----
function render(level){
  ctx.clearRect(0,0,W,H);
  const grd = ctx.createLinearGradient(0, Date.now()%H, W, H);
  grd.addColorStop(0, '#b3ecff'); grd.addColorStop(1, '#e6fcff');
  ctx.fillStyle = grd; ctx.fillRect(0,0,W,H);

  ctx.save(); ctx.translate(0, -cameraY);
  for (const p of level.platforms){ if (!p.hidden){ ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.width, p.height); } }
  for (const o of level.obstacles){ ctx.fillStyle = o.color; ctx.beginPath(); ctx.moveTo(o.x, o.y + o.size); ctx.lineTo(o.x + o.size/2, o.y); ctx.lineTo(o.x + o.size, o.y + o.size); ctx.closePath(); ctx.fill(); }

  // portal animation (rotating conic gradient rectangle)
  ctx.save();
  const cx = level.portal.x + level.portal.width/2;
  const cy = level.portal.y + level.portal.height/2;
  ctx.translate(cx, cy);
  ctx.rotate(level.portal.angle * Math.PI / 180);
  // fallback radial gradient if conic not supported
  if (ctx.createConicGradient){
    const g = ctx.createConicGradient(0, 0, 0);
    g.addColorStop(0, 'rgba(0,255,247,0.9)'); g.addColorStop(0.5, 'rgba(123,47,247,0.9)'); g.addColorStop(1, 'rgba(0,255,247,0.9)');
    ctx.fillStyle = g;
  } else {
    const rg = ctx.createRadialGradient(0,0,2,0,0,Math.max(level.portal.width, level.portal.height));
    rg.addColorStop(0,'rgba(0,255,247,0.9)'); rg.addColorStop(0.5,'rgba(123,47,247,0.9)'); rg.addColorStop(1,'rgba(0,255,247,0.5)');
    ctx.fillStyle = rg;
  }
  ctx.fillRect(-level.portal.width/2, -level.portal.height/2, level.portal.width, level.portal.height);
  ctx.restore();

  // draw player with outline and expression
  ctx.fillStyle = playerColor; ctx.fillRect(player.x, player.y, player.w, player.h);
  ctx.strokeStyle = outlineColor; ctx.lineWidth = 2; ctx.strokeRect(player.x, player.y, player.w, player.h);
  ctx.fillStyle = '#000'; ctx.font = '16px monospace'; ctx.fillText(playerExpression, player.x + 5, player.y + 25);

  ctx.restore();

  document.getElementById('score').textContent = score;
}

// ----- UI HOOKS (start menu, tutorial, custom menu) -----
const startMenu = document.getElementById('startMenu');
const tutorialMenu = document.getElementById('tutorialMenu');
startMenu.style.display = 'flex';

document.getElementById('playBtn').onclick = () => { startMenu.style.display = 'none'; loadLevel(0); requestAnimationFrame(update); };
document.getElementById('loadGameBtn').onclick = () => { startMenu.style.display = 'none'; loadGame(); requestAnimationFrame(update); };
document.getElementById('customizeStartBtn').onclick = () => { customizeMenu.style.display = 'flex'; updatePreview(); };
document.getElementById('tutorialBtn').onclick = () => { startMenu.style.display = 'none'; tutorialMenu.style.display = 'flex'; };
document.getElementById('tutorialBackBtn').onclick = () => { tutorialMenu.style.display = 'none'; startMenu.style.display = 'flex'; };

// ----- Initialize a fresh level in case of immediate play -----
loadLevel(0);
</script>
</body>
</html>
